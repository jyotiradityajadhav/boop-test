<<header
    Name: Jyotiraditya Jadhav, Quayim Qadri, Rizwan Gulzarmir
    Assignment: Problem 4: Stalin Sort
    Date: 29th November 2025
    Professor: Prof. Aalok D. Thakkar
header>>

<<problem 4: "Stalin Sort"

<<blueprint
        <<functional-correctness
            requires: 
                input is a list of comparable elements
            ensures:
                returns a sorted list in non-decreasing order
                every element in output appears in input in the same relative order
                the output is a subsequence of the input
                for all i in [0, length(output)-2], output[i] <= output[i+1]
        functional-correctness>>
blueprint>>

<<operational steps
    Step 1: Process the input list from left to right
    
    Step 2: Maintain the last kept element to compare with current element
    
    Step 3: For each element, check if it should be kept based on comparison
            with the last kept element
    
    Step 4: Build the result list by accumulating elements that maintain order
    
    Step 5: Return the final accumulated list
operational steps>>

<<ocaml-code
let stalin_sort (input_list : int list) : int list =
  let result = [] in
  let last_element = 0 in
  let process_element (current : int) ((last, res) : int * int list) : int * int list =
    match current >= last with
    | true -> (current, current :: res)
    | false -> (last, res)
  in
  let process_list (lst : int list) (start_val : int) : int list =
    let final_state = List.fold_left process_element (start_val, []) lst in
    let (_, reversed_result) = final_state in
    List.rev reversed_result
  in
  match input_list with
  | [] -> []
  | first :: rest -> 
      let initial_state = (first, [first]) in
      let final_state = List.fold_left process_element initial_state rest in
      let (_, reversed_result) = final_state in
      List.rev reversed_result

ocaml-code>>

<<proof
        <<invariant
            Initialisation: 
                Start with first element of input list
                Invariant: accumulated list is always sorted in non-decreasing order
                
            Maintenance:
                At each step, we only add elements that are >= last kept element
                This maintains the sorted property
                The fold operation processes elements in original order
                
            Termination:
                List.fold_left processes all elements exactly once
                Algorithm terminates when all elements are processed
        invariant>>

        <<induction
            Base case: Empty list returns empty list (trivially sorted)
            
            Inductive step:
                For non-empty list, we process elements sequentially
                Each decision to keep or skip maintains the sorted property
                By structural induction on lists, the result is always sorted
                and maintains original order of kept elements
        induction>>
        
proof>>

problem>>


